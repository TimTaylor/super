[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 glue authors Copyright (c) 2024 super authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/super.html","id":"differences-from-glue","dir":"Articles","previous_headings":"","what":"Differences from glue","title":"super","text":"super::glue() takes two arguments: character string used template environment look embraced inputs. option change delimiters pair braces (e.g. name). Embraced inputs always looked provided environment (akin calling [get()]) evaluated. similar glue::glue_safe() glue::glue_data_safe() note default behaviour glue::glue(). super::glue() trim inputs. Instead done either function super::glut() explicitly glue(trim(x)). super::glue() returns unclassed character vector whereas glue::glue() returns <glue> object provides variety methods work object. present, super::glue() provide allowance different handling NA NULL values, instead following behaviour paste(). Recycling embraced arguments currently follows standard R recycling rules arguments recycled length longest one. glue::glue() arguments (associated behaviours) .comment, .literal .transformer implemented.","code":""},{"path":"/articles/super.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"super","text":"","code":"library(super)"},{"path":"/articles/super.html","id":"simple-concatenation","dir":"Articles","previous_headings":"Examples","what":"Simple concatenation","title":"super","text":"","code":"bar <- \"baz\" glue(\"foo{bar}\") ## [1] \"foobaz\""},{"path":"/articles/super.html","id":"list-like-input","dir":"Articles","previous_headings":"Examples","what":"list-like input","title":"super","text":"","code":"dat <- head(cbind(car = rownames(mtcars), mtcars)) glue(\"{car} does {mpg} mpg.\", dat) ## [1] \"Mazda RX4 does 21 mpg.\"           \"Mazda RX4 Wag does 21 mpg.\"       ## [3] \"Datsun 710 does 22.8 mpg.\"        \"Hornet 4 Drive does 21.4 mpg.\"    ## [5] \"Hornet Sportabout does 18.7 mpg.\" \"Valiant does 18.1 mpg.\""},{"path":"/articles/super.html","id":"trimmed-output","dir":"Articles","previous_headings":"Examples","what":"Trimmed output","title":"super","text":"","code":"name <- \"Fred\" age <- 50 anniversary <- as.Date(\"1991-10-12\") out <- glut(\"     My name is {name},     my age next year is {age},     my anniversary is {anniversary}. \") cat(out) ## My name is Fred, ## my age next year is 50, ## my anniversary is 1991-10-12."},{"path":"/articles/super.html","id":"partially-vectorised","dir":"Articles","previous_headings":"Examples","what":"Partially vectorised","title":"super","text":"embraced arguments input strings (yet)","code":"head(glue(\"Item {LETTERS}\")) ## [1] \"Item A\" \"Item B\" \"Item C\" \"Item D\" \"Item E\" \"Item F\" tryCatch(     glue(letters),     error = function(e) conditionMessage(e) ) ## [1] \"`x` must be a character vector of length <= 1.\""},{"path":"/articles/super.html","id":"relative-timing-benchmarks","dir":"Articles","previous_headings":"","what":"Relative timing benchmarks","title":"super","text":"","code":"library(microbenchmark)"},{"path":"/articles/super.html","id":"simple-concatenation-1","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Simple concatenation","title":"super","text":"","code":"bar <- \"baz\" bob <- 20  microbenchmark(     sprintf    = sprintf(\"foo%s %d\", bar, bob),     paste0     = paste0(\"foo\", bar, \" \", bob),     super   = super::glue(\"foo{bar} {bob}\"),     glue    = as.character(glue::glue_safe(\"foo{bar} {bob}\", .trim = FALSE)),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##     expr       min        lq      mean    median        uq        max neval ##  sprintf  1.000000  1.000000  1.000000  1.000000  1.000000  1.0000000   100 ##   paste0  2.839925  2.527308  1.836329  1.683049  1.789630  0.3086444   100 ##    super  9.810734  8.680157  6.616491  6.423771  6.082686  3.8124959   100 ##     glue 85.196798 72.780354 49.459336 47.073972 43.397670 12.5700178   100"},{"path":"/articles/super.html","id":"data-frame-input","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Data frame input","title":"super","text":"","code":"dat <- head(cbind(car = rownames(mtcars), mtcars))  microbenchmark(     sprintf = with(dat, sprintf(\"%s does %.3g mpg.\", car, mpg)),     paste0  = with(dat, paste(car, \"does\", mpg, \"mpg.\")),     super   = super::glue(\"{car} does {mpg} mpg.\", dat),     glue    = as.character(glue::glue_data(dat, \"{car} does {mpg} mpg.\")),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##     expr       min        lq      mean    median        uq       max neval ##  sprintf  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000   100 ##   paste0  1.636848  1.602644  1.555155  1.528677  1.431333  2.454490   100 ##    super  2.943516  2.846574  2.681556  2.908811  2.572647  1.537183   100 ##     glue 19.603430 18.366401 16.246234 16.688740 14.547217 10.842833   100"},{"path":"/articles/super.html","id":"trimmed-output-1","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Trimmed output","title":"super","text":"","code":"microbenchmark(     super   = super::glut(\"                   My name is {name},                   my age next year is {age},                   my anniversary is {anniversary}.               \"),     glue    = as.character(glue::glue(\"                   My name is {name},                   my age next year is {age},                   my anniversary is {anniversary}.               \")),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##   expr      min       lq     mean   median       uq      max neval ##  super 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000   100 ##   glue 3.829421 3.699996 3.589724 3.597093 3.621335 1.757523   100"},{"path":"/articles/super.html","id":"vectorized-performance","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Vectorized performance","title":"super","text":"","code":"bar <- rep(\"baz\", 1e5) microbenchmark(     sprintf    = sprintf(\"foo%s %d\", bar, bob),     paste0     = paste0(\"foo\", bar, \" \", bob),     super   = super::glue(\"foo{bar} {bob}\"),     glue    = as.character(glue::glue_safe(\"foo{bar} {bob}\", .trim = FALSE)),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##     expr      min       lq     mean   median       uq       max neval ##  sprintf 1.515219 1.491733 1.481768 1.471056 1.470214 1.4489158   100 ##   paste0 1.000000 1.000000 1.000000 1.000000 1.000000 1.0000000   100 ##    super 1.001219 1.003483 1.005976 1.002883 1.003300 0.9968706   100 ##     glue 1.070956 1.055485 1.059997 1.040508 1.054012 1.0612620   100"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tim Taylor. Author, maintainer. Jim Hester. Author. Jennifer Bryan. Author. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor T, Hester J, Bryan J (2024). super: Interpreted String Literals. R package version 0.0.1.9000.","code":"@Manual{,   title = {super: Interpreted String Literals},   author = {Tim Taylor and Jim Hester and Jennifer Bryan},   year = {2024},   note = {R package version 0.0.1.9000}, }"},{"path":"/index.html","id":"super","dir":"","previous_headings":"","what":"Interpreted String Literals","title":"Interpreted String Literals","text":"NOTE: super still somewhat experimental nature treated 0.1.0 release. package yet CRAN hopefully land near future. development version super can installed r-universe:","code":"install.packages('super', repos = c('https://tim.r-universe.dev', 'https://cloud.r-project.org'))"},{"path":"/reference/glue.html","id":null,"dir":"Reference","previous_headings":"","what":"Format and interpolate a string — glue","title":"Format and interpolate a string — glue","text":"Inputs enclosed braces (e.g. {name}) looked provided environment (akin calling get()). Single braces can escaped doubling . Variables recycled length largest one. glue() operates string . glut() trim input prior glueing.","code":""},{"path":"/reference/glue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format and interpolate a string — glue","text":"","code":"glue(x, env = parent.frame())  glut(x, env = parent.frame())"},{"path":"/reference/glue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format and interpolate a string — glue","text":"x [character string] env [environment] look embraced input. Can environment list-like object converted underlying function via list2env().","code":""},{"path":"/reference/glue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format and interpolate a string — glue","text":"character object.","code":""},{"path":[]},{"path":"/reference/glue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format and interpolate a string — glue","text":"","code":"name <- \"Fred\" age <- 50 cat(glue(\"My name is {name} and my age next year is {age}\")) #> My name is Fred and my age next year is 50  # glut first trims the output anniversary <- as.Date(\"1991-10-12\") cat(glut(\"     My name is {name},     my age next year is {age},     my anniversary is {anniversary}. \")) #> My name is Fred, #> my age next year is 50, #> my anniversary is 1991-10-12.  # single braces can be inserted by doubling them glue(\"My name is {name}, not {{name}}.\") #> [1] \"My name is Fred, not {name}.\"  # List like objects can be used in place of an environment dat <- cbind(car = rownames(mtcars), mtcars) glue(\"{car} does {mpg} mpg.\", dat) #>  [1] \"Mazda RX4 does 21 mpg.\"             \"Mazda RX4 Wag does 21 mpg.\"         #>  [3] \"Datsun 710 does 22.8 mpg.\"          \"Hornet 4 Drive does 21.4 mpg.\"      #>  [5] \"Hornet Sportabout does 18.7 mpg.\"   \"Valiant does 18.1 mpg.\"             #>  [7] \"Duster 360 does 14.3 mpg.\"          \"Merc 240D does 24.4 mpg.\"           #>  [9] \"Merc 230 does 22.8 mpg.\"            \"Merc 280 does 19.2 mpg.\"            #> [11] \"Merc 280C does 17.8 mpg.\"           \"Merc 450SE does 16.4 mpg.\"          #> [13] \"Merc 450SL does 17.3 mpg.\"          \"Merc 450SLC does 15.2 mpg.\"         #> [15] \"Cadillac Fleetwood does 10.4 mpg.\"  \"Lincoln Continental does 10.4 mpg.\" #> [17] \"Chrysler Imperial does 14.7 mpg.\"   \"Fiat 128 does 32.4 mpg.\"            #> [19] \"Honda Civic does 30.4 mpg.\"         \"Toyota Corolla does 33.9 mpg.\"      #> [21] \"Toyota Corona does 21.5 mpg.\"       \"Dodge Challenger does 15.5 mpg.\"    #> [23] \"AMC Javelin does 15.2 mpg.\"         \"Camaro Z28 does 13.3 mpg.\"          #> [25] \"Pontiac Firebird does 19.2 mpg.\"    \"Fiat X1-9 does 27.3 mpg.\"           #> [27] \"Porsche 914-2 does 26 mpg.\"         \"Lotus Europa does 30.4 mpg.\"        #> [29] \"Ford Pantera L does 15.8 mpg.\"      \"Ferrari Dino does 19.7 mpg.\"        #> [31] \"Maserati Bora does 15 mpg.\"         \"Volvo 142E does 21.4 mpg.\""},{"path":"/reference/super-package.html","id":null,"dir":"Reference","previous_headings":"","what":"super: Interpreted String Literals — super-package","title":"super: Interpreted String Literals — super-package","text":"implementation interpreted string literals. Based glue package (https://glue.tidyverse.org/) focus efficiency simplicity cost flexibility.","code":""},{"path":[]},{"path":"/reference/super-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"super: Interpreted String Literals — super-package","text":"Maintainer: Tim Taylor tim.taylor@hiddenelephants.co.uk (ORCID) Authors: Jim Hester (ORCID) Jennifer Bryan (ORCID) contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"/reference/trim.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim a character vector — trim","title":"Trim a character vector — trim","text":"Almost identical glue::trim() save slight difference error handling non-character input. function trims character vector according trimming rules used glue. follow similar rules Python Docstrings, following features: Leading trailing whitespace first last lines removed. uniform amount indentation stripped second line , equal minimum indentation non-blank lines first. Lines can continued across newlines using \\\\.","code":""},{"path":"/reference/trim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim a character vector — trim","text":"","code":"trim(x)"},{"path":"/reference/trim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim a character vector — trim","text":"x [character].","code":""},{"path":"/reference/trim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim a character vector — trim","text":"character vector.","code":""},{"path":[]},{"path":"/reference/trim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trim a character vector — trim","text":"","code":"cat(trim(\"     A formatted string     Can have multiple lines       with additional indentation preserved     \")) #> A formatted string #> Can have multiple lines #>   with additional indentation preserved  cat(trim(\"   \\ntrailing or leading newlines can be added explicitly\\n   \")) #>    #> trailing or leading newlines can be added explicitly  cat(trim(\"     A formatted string \\\\     can also be on a \\\\     single line     \")) #> A formatted string can also be on a single line"}]
