[{"path":"https://timtaylor.github.io/super/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 glue authors Copyright (c) 2024 super authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"differences-from-glue","dir":"Articles","previous_headings":"","what":"Differences from glue","title":"super","text":"super::glue() takes two arguments: character string used template environment look embraced inputs. option change delimiters pair braces (e.g. name). Embraced inputs always looked provided environment (akin calling get()) evaluated. similar glue::glue_safe() glue::glue_data_safe() note default behaviour glue::glue(). super::glue() trim inputs. Instead done either function super::glut() explicitly glue(trim(x)). super::glue() returns unclassed character vector whereas glue::glue() returns <glue> object provides variety methods work object. present, super::glue() provide allowance different handling NA NULL values, instead following behaviour paste(). Recycling embraced arguments currently follows standard R recycling rules arguments recycled length longest one. glue::glue() arguments (associated behaviours) .comment, .literal .transformer implemented.","code":""},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"super","text":"","code":"library(super)"},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"simple-concatenation","dir":"Articles","previous_headings":"Examples","what":"Simple concatenation","title":"super","text":"","code":"bar <- \"baz\" glue(\"foo{bar}\") ## [1] \"foobaz\""},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"list-like-input","dir":"Articles","previous_headings":"Examples","what":"list-like input","title":"super","text":"","code":"dat <- head(cbind(car = rownames(mtcars), mtcars)) glue(\"{car} does {mpg} mpg.\", dat) ## [1] \"Mazda RX4 does 21 mpg.\"           \"Mazda RX4 Wag does 21 mpg.\"       ## [3] \"Datsun 710 does 22.8 mpg.\"        \"Hornet 4 Drive does 21.4 mpg.\"    ## [5] \"Hornet Sportabout does 18.7 mpg.\" \"Valiant does 18.1 mpg.\""},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"trimmed-output","dir":"Articles","previous_headings":"Examples","what":"Trimmed output","title":"super","text":"","code":"name <- \"Fred\" age <- 50 anniversary <- as.Date(\"1991-10-12\") out <- glut(\"     My name is {name},     my age next year is {age},     my anniversary is {anniversary}. \") cat(out) ## My name is Fred, ## my age next year is 50, ## my anniversary is 1991-10-12."},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"partially-vectorised","dir":"Articles","previous_headings":"Examples","what":"Partially vectorised","title":"super","text":"embraced arguments input strings (yet)","code":"head(glue(\"Item {LETTERS}\")) ## [1] \"Item A\" \"Item B\" \"Item C\" \"Item D\" \"Item E\" \"Item F\" tryCatch(     glue(letters),     error = function(e) conditionMessage(e) ) ## [1] \"`x` must be a character vector of length <= 1.\""},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"relative-timing-benchmarks","dir":"Articles","previous_headings":"","what":"Relative timing benchmarks","title":"super","text":"","code":"library(microbenchmark)"},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"simple-concatenation-1","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Simple concatenation","title":"super","text":"","code":"bar <- \"baz\" bob <- 20  microbenchmark(     sprintf    = sprintf(\"foo%s %d\", bar, bob),     paste0     = paste0(\"foo\", bar, \" \", bob),     super   = super::glue(\"foo{bar} {bob}\"),     glue    = as.character(glue::glue_safe(\"foo{bar} {bob}\", .trim = FALSE)),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##     expr       min        lq      mean    median        uq       max neval ##  sprintf  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000   100 ##   paste0  2.775187  2.481279  1.745639  1.639921  1.662462  0.280487   100 ##    super  9.523321  8.416537  6.335171  6.257058  5.769900  3.568722   100 ##     glue 82.972015 71.439548 47.851497 45.994799 41.233797 12.032294   100"},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"data-frame-input","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Data frame input","title":"super","text":"","code":"dat <- head(cbind(car = rownames(mtcars), mtcars))  microbenchmark(     sprintf = with(dat, sprintf(\"%s does %.3g mpg.\", car, mpg)),     paste0  = with(dat, paste(car, \"does\", mpg, \"mpg.\")),     super   = super::glue(\"{car} does {mpg} mpg.\", dat),     glue    = as.character(glue::glue_data(dat, \"{car} does {mpg} mpg.\")),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##     expr       min        lq      mean    median        uq       max neval ##  sprintf  1.000000  1.000000  1.000000  1.000000  1.000000  1.000000   100 ##   paste0  1.654844  1.601215  1.526179  1.513622  1.401234  3.377220   100 ##    super  2.857394  2.835256  2.699015  2.854620  2.549984  2.442783   100 ##     glue 19.163711 18.290435 16.382850 16.483709 14.502144 18.107625   100"},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"trimmed-output-1","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Trimmed output","title":"super","text":"","code":"microbenchmark(     super   = super::glut(\"                   My name is {name},                   my age next year is {age},                   my anniversary is {anniversary}.               \"),     glue    = as.character(glue::glue(\"                   My name is {name},                   my age next year is {age},                   my anniversary is {anniversary}.               \")),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##   expr      min       lq     mean   median       uq      max neval ##  super 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000   100 ##   glue 3.788773 3.724761 3.607342 3.607658 3.591182 1.857413   100"},{"path":"https://timtaylor.github.io/super/articles/super.html","id":"vectorized-performance","dir":"Articles","previous_headings":"Relative timing benchmarks","what":"Vectorized performance","title":"super","text":"larger input glue::glue() super::glue(), performance becomes dominated internally constructed call paste0(), hence convergence observed .","code":"bar <- rep(\"baz\", 1e5) microbenchmark(     sprintf    = sprintf(\"foo%s %d\", bar, bob),     paste0     = paste0(\"foo\", bar, \" \", bob),     super   = super::glue(\"foo{bar} {bob}\"),     glue    = as.character(glue::glue_safe(\"foo{bar} {bob}\", .trim = FALSE)),     unit    = \"relative\",     check   = \"identical\" ) ## Unit: relative ##     expr      min        lq     mean   median       uq      max neval ##  sprintf 1.536963 1.5444128 1.589803 1.622070 1.630023 1.693708   100 ##   paste0 1.000000 1.0000000 1.000000 1.000000 1.000000 1.000000   100 ##    super 1.017472 0.9984926 1.006781 1.001831 1.003322 1.103445   100 ##     glue 1.090289 1.0532831 1.063225 1.043023 1.055868 1.168411   100"},{"path":"https://timtaylor.github.io/super/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tim Taylor. Author, maintainer. Jim Hester. Author. Jennifer Bryan. Author. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"https://timtaylor.github.io/super/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor T, Hester J, Bryan J (2024). super: Interpreted String Literals. R package version 0.0.3, https://timtaylor.github.io/super/.","code":"@Manual{,   title = {super: Interpreted String Literals},   author = {Tim Taylor and Jim Hester and Jennifer Bryan},   year = {2024},   note = {R package version 0.0.3},   url = {https://timtaylor.github.io/super/}, }"},{"path":"https://timtaylor.github.io/super/index.html","id":"super","dir":"","previous_headings":"","what":"Interpreted String Literals","title":"Interpreted String Literals","text":"NOTE: package much experimental nature treated 0.1.0 release. super fork / reimplementation glue package focus efficiency simplicity cost flexibility.","code":""},{"path":"https://timtaylor.github.io/super/index.html","id":"installing-the-package","dir":"","previous_headings":"","what":"Installing the package","title":"Interpreted String Literals","text":"can install latest release super CRAN : development version can installed r-universe :","code":"install.packages(\"super\") install.packages(     'super',     repos = c('https://timtaylor.r-universe.dev', 'https://cloud.r-project.org') )"},{"path":"https://timtaylor.github.io/super/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Interpreted String Literals","text":"brief overview super provided vignette distributed package: vignette(\"super\", package = \"super\")","code":""},{"path":"https://timtaylor.github.io/super/reference/glue.html","id":null,"dir":"Reference","previous_headings":"","what":"Format and interpolate a string — glue","title":"Format and interpolate a string — glue","text":"Inputs enclosed braces (e.g. {name}) looked provided environment (akin calling get()). Single braces can escaped doubling . Variables recycled length largest one. glue() operates string . glut() trim input prior glueing.","code":""},{"path":"https://timtaylor.github.io/super/reference/glue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format and interpolate a string — glue","text":"","code":"glue(x, env = parent.frame())  glut(x, env = parent.frame())"},{"path":"https://timtaylor.github.io/super/reference/glue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format and interpolate a string — glue","text":"x [character string] env [environment] look embraced input. Can environment list-like object converted underlying function via list2env().","code":""},{"path":"https://timtaylor.github.io/super/reference/glue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format and interpolate a string — glue","text":"character object.","code":""},{"path":[]},{"path":"https://timtaylor.github.io/super/reference/glue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format and interpolate a string — glue","text":"","code":"name <- \"Fred\" age <- 50 cat(glue(\"My name is {name} and my age next year is {age}\")) #> My name is Fred and my age next year is 50  # glut first trims the output anniversary <- as.Date(\"1991-10-12\") cat(glut(\"     My name is {name},     my age next year is {age},     my anniversary is {anniversary}. \")) #> My name is Fred, #> my age next year is 50, #> my anniversary is 1991-10-12.  # single braces can be inserted by doubling them glue(\"My name is {name}, not {{name}}.\") #> [1] \"My name is Fred, not {name}.\"  # List like objects can be used in place of an environment dat <- cbind(car = rownames(mtcars), mtcars) glue(\"{car} does {mpg} mpg.\", dat) #>  [1] \"Mazda RX4 does 21 mpg.\"             \"Mazda RX4 Wag does 21 mpg.\"         #>  [3] \"Datsun 710 does 22.8 mpg.\"          \"Hornet 4 Drive does 21.4 mpg.\"      #>  [5] \"Hornet Sportabout does 18.7 mpg.\"   \"Valiant does 18.1 mpg.\"             #>  [7] \"Duster 360 does 14.3 mpg.\"          \"Merc 240D does 24.4 mpg.\"           #>  [9] \"Merc 230 does 22.8 mpg.\"            \"Merc 280 does 19.2 mpg.\"            #> [11] \"Merc 280C does 17.8 mpg.\"           \"Merc 450SE does 16.4 mpg.\"          #> [13] \"Merc 450SL does 17.3 mpg.\"          \"Merc 450SLC does 15.2 mpg.\"         #> [15] \"Cadillac Fleetwood does 10.4 mpg.\"  \"Lincoln Continental does 10.4 mpg.\" #> [17] \"Chrysler Imperial does 14.7 mpg.\"   \"Fiat 128 does 32.4 mpg.\"            #> [19] \"Honda Civic does 30.4 mpg.\"         \"Toyota Corolla does 33.9 mpg.\"      #> [21] \"Toyota Corona does 21.5 mpg.\"       \"Dodge Challenger does 15.5 mpg.\"    #> [23] \"AMC Javelin does 15.2 mpg.\"         \"Camaro Z28 does 13.3 mpg.\"          #> [25] \"Pontiac Firebird does 19.2 mpg.\"    \"Fiat X1-9 does 27.3 mpg.\"           #> [27] \"Porsche 914-2 does 26 mpg.\"         \"Lotus Europa does 30.4 mpg.\"        #> [29] \"Ford Pantera L does 15.8 mpg.\"      \"Ferrari Dino does 19.7 mpg.\"        #> [31] \"Maserati Bora does 15 mpg.\"         \"Volvo 142E does 21.4 mpg.\""},{"path":"https://timtaylor.github.io/super/reference/super-package.html","id":null,"dir":"Reference","previous_headings":"","what":"super: Interpreted String Literals — super-package","title":"super: Interpreted String Literals — super-package","text":"implementation interpreted string literals. Based 'glue' package Hester & Bryan (2024) doi:10.32614/CRAN.package.glue  focus efficiency simplicity cost flexibility.","code":""},{"path":[]},{"path":"https://timtaylor.github.io/super/reference/super-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"super: Interpreted String Literals — super-package","text":"Maintainer: Tim Taylor tim.taylor@hiddenelephants.co.uk (ORCID) Authors: Jim Hester (ORCID) Jennifer Bryan (ORCID) contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://timtaylor.github.io/super/reference/trim.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim a character vector — trim","title":"Trim a character vector — trim","text":"Almost identical glue::trim() save slight difference error handling non-character input. function trims character vector according trimming rules used glue. follow similar rules Python Docstrings, following features: Leading trailing whitespace first last lines removed. uniform amount indentation stripped second line , equal minimum indentation non-blank lines first. Lines can continued across newlines using \\\\.","code":""},{"path":"https://timtaylor.github.io/super/reference/trim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim a character vector — trim","text":"","code":"trim(x)"},{"path":"https://timtaylor.github.io/super/reference/trim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim a character vector — trim","text":"x [character].","code":""},{"path":"https://timtaylor.github.io/super/reference/trim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim a character vector — trim","text":"character vector.","code":""},{"path":[]},{"path":"https://timtaylor.github.io/super/reference/trim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trim a character vector — trim","text":"","code":"cat(trim(\"     A formatted string     Can have multiple lines       with additional indentation preserved     \")) #> A formatted string #> Can have multiple lines #>   with additional indentation preserved  cat(trim(\"   \\ntrailing or leading newlines can be added explicitly\\n   \")) #>    #> trailing or leading newlines can be added explicitly  cat(trim(\"     A formatted string \\\\     can also be on a \\\\     single line     \")) #> A formatted string can also be on a single line"}]
